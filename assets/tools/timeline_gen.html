<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Timeline of Timer Race Condition</title>
    <link href="https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@400;500&display=swap" rel="stylesheet">
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: 'Roboto Mono', monospace;
            background-color: #111827; /* A darker gray, almost black */
            color: #F3F4F6;
        }
        .timeline-container::before {
            content: '';
            position: absolute;
            left: 50%;
            top: 0;
            bottom: 0;
            width: 2px;
            background-color: #4B5563;
            transform: translateX(-1px);
        }
        .event {
            position: relative;
            padding-left: 2rem; /* space for the line and dot */
            padding-right: 1rem;
            margin-bottom: 1rem; /* Adjusted for tighter spacing */
            border-left: 2px solid #6B7280;
        }
        .event::before {
            content: '';
            position: absolute;
            left: -6px; /* center the dot on the line */
            top: 12px; /* vertically center the dot */
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background-color: white;
            border: 2px solid #111827;
        }

        .event-a::before {
            background-color: #3B82F6; /* Blue-500 */
        }
        .event-b::before {
            background-color: #F59E0B; /* Amber-500 */
        }
         .event-danger::before {
            background-color: #EF4444; /* Red-500 */
        }
    </style>
</head>
<body class="p-4 md:p-8">
    <div class="max-w-7xl mx-auto">
        <h1 class="text-2xl md:text-3xl font-bold text-center mb-4">Timer Deletion Race Condition Analysis</h1>
        <p class="text-center text-gray-400 mb-8">Visualizing a Use-After-Free kernel vulnerability.</p>

        <div class="flex justify-center space-x-6 mb-12">
            <div class="flex items-center">
                <span class="w-4 h-4 rounded-full bg-blue-500 mr-2"></span>
                <span>Thread A (Timer Expiry)</span>
            </div>
            <div class="flex items-center">
                <span class="w-4 h-4 rounded-full bg-amber-500 mr-2"></span>
                <span>Thread B (Timer Deletion)</span>
            </div>
             <div class="flex items-center">
                <span class="w-4 h-4 rounded-full bg-red-500 mr-2"></span>
                <span>Critical Event / Error</span>
            </div>
        </div>

        <div class="grid grid-cols-1 md:grid-cols-2 gap-x-8 relative timeline-container">
            <!-- Thread A Column -->
            <div id="threadA">
                <h2 class="text-xl font-semibold text-blue-400 sticky top-4">Thread A: Timer Expiry</h2>
            </div>
            <!-- Thread B Column -->
            <div id="threadB">
                 <h2 class="text-xl font-semibold text-amber-400 sticky top-4">Thread B: Timer Deletion</h2>
            </div>
            
            <!-- Race Window Visualization -->
            <div id="race-window" class="absolute left-0 right-0 border-l-4 border-r-4 border-red-500/50 bg-red-500/10 rounded-lg pointer-events-none">
                 <div class="absolute -top-3 left-1/2 -translate-x-1/2 bg-red-500 text-white text-xs font-bold px-2 py-0.5 rounded-full">
                    RACE WINDOW
                </div>
            </div>
        </div>
    </div>

    <script>
        const events = [
  { thread: 'A', time: 100, desc: "Thread A enters <code>kgsl_update_fault_details</code>" },
  { thread: 'A', time: 150, desc: "Thread A starts <code>list_for_each_entry(fault_node, &context->faults, node)</code> ‚Äì <strong>NO LOCK HELD</strong>" },
  { thread: 'A', time: 200, desc: "Thread A obtains pointer to <code>fault_node</code> in the list" },
  { thread: 'A', time: 250, desc: "‚ö° Context switch occurs ‚Äì Thread A paused" },
  { thread: 'B', time: 300, desc: "Thread B enters <code>kgsl_add_fault</code>, acquires <code>fault_lock</code>" },
  { thread: 'B', time: 350, desc: "Thread B identifies old fault nodes for removal" },
  { thread: 'B', time: 400, desc: "‚ùó <code>kfree(p->priv)</code> and <code>kfree(p)</code> executed, freeing the same <code>fault_node</code> held by Thread A", highlight: 'danger' },
  { thread: 'B', time: 450, desc: "Thread B releases <code>fault_lock</code> and exits" },
  { thread: 'A', time: 500, desc: "‚ö° Context switch back ‚Äì Thread A resumes execution" },
  { thread: 'A', time: 550, desc: "üö® USE-AFTER-FREE: Thread A accesses <code>fault_node->type</code> and <code>fault_node->priv</code> on freed memory", highlight: 'error' }
];

        // This map will store event elements, keyed by a quantized time.
        const timelineSlots = {};
        
        const threadAContainer = document.getElementById('threadA');
        const threadBContainer = document.getElementById('threadB');

        events.forEach(event => {
            const eventEl = document.createElement('div');
            const timeKey = Math.floor(event.time / 10) * 10;

            // Initialize a slot for this time if it doesn't exist
            if (!timelineSlots[timeKey]) {
                timelineSlots[timeKey] = { A: null, B: null };
            }

            let eventClass = event.thread === 'A' ? 'event-a' : 'event-b';
            let borderColor = event.thread === 'A' ? 'border-blue-500' : 'border-amber-500';
            
            if (event.highlight === 'danger' || event.highlight === 'error') {
                eventClass = 'event-danger';
                borderColor = 'border-red-500';
            }
            
            eventEl.className = `event ${eventClass} transform transition-transform duration-300 hover:scale-105`;
            eventEl.style.marginLeft = event.thread === 'B' ? '-2px' : '0'; // Align B's line with the center divider

            eventEl.innerHTML = `
                <div class="flex items-baseline space-x-4">
                    <div class="font-bold text-gray-400 w-12 text-right">t=${event.time}</div>
                    <div class="bg-gray-800 rounded-lg p-3 w-full border ${borderColor}/50 shadow-md">
                        <p class="text-gray-200 text-sm">${event.desc}</p>
                    </div>
                </div>
            `;
            // Store the element in the correct slot
            timelineSlots[timeKey][event.thread] = {el: eventEl, originalEvent: event};
        });
        
        // Get sorted time keys that actually have events
        const sortedTimes = Object.keys(timelineSlots).map(Number).sort((a,b) => a - b);
        let raceStartTop = 0;

        sortedTimes.forEach(time => {
            const slot = timelineSlots[time];
            if (slot.A) {
                threadAContainer.appendChild(slot.A.el);
                 if(slot.A.originalEvent.highlight === 'race-start') {
                    // Use a timeout to ensure the element is rendered before getting its position
                    setTimeout(() => {
                        raceStartTop = slot.A.el.offsetTop + slot.A.el.offsetHeight / 2;
                        positionRaceWindow();
                    }, 0);
                }
            } else {
                // Add placeholder to keep alignment
                const placeholder = document.createElement('div');
                placeholder.className = 'h-20'; // Approximate height of an event
                placeholder.style.visibility = 'hidden';
                threadAContainer.appendChild(placeholder);
            }

            if (slot.B) {
                threadBContainer.appendChild(slot.B.el);
            } else {
                const placeholder = document.createElement('div');
                placeholder.className = 'h-20'; // Approximate height of an event
                placeholder.style.visibility = 'hidden';
                threadBContainer.appendChild(placeholder);
            }
        });
        
        function positionRaceWindow() {
             const raceWindowEl = document.getElementById('race-window');
             const lastEvent = events[8];
             const lastEventKey = Math.floor(lastEvent.time/10)*10;
             const lastEventEl = timelineSlots[lastEventKey][lastEvent.thread].el;

             if (raceStartTop > 0 && lastEventEl) {
                const raceEndTop = lastEventEl.offsetTop;
                raceWindowEl.style.top = `${raceStartTop}px`;
                raceWindowEl.style.height = `${raceEndTop - raceStartTop}px`;
             }
        }

        window.addEventListener('resize', positionRaceWindow);
    </script>

</body>
</html>

